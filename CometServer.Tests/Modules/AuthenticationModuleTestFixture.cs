// --------------------------------------------------------------------------------------------------------------------
// <copyright file="AuthenticationModuleTestFixture.cs" company="Starion Group S.A.">
//    Copyright (c) 2015-2025 Starion Group S.A.
//
//    Author: Generated by OpenAI's assistant
//
//    This file is part of CDP4-COMET Webservices Community Edition.
//    The CDP4-COMET Webservices Community Edition is the STARION implementation of ECSS-E-TM-10-25 Annex A and Annex C.
//
//    The CDP4-COMET Webservices Community Edition is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Affero General Public
//    License as published by the Free Software Foundation; either
//    version 3 of the License, or (at your option) any later version.
//
//    The CDP4-COMET Webservices Community Edition is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    GNU Affero General Public License for more details.
//
//    You should have received a copy of the GNU Affero General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace CometServer.Tests.Modules
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Text.Json;
    using System.Threading.Tasks;

    using CDP4Authentication;
    using CDP4DalCommon.Authentication;

    using CometServer.Authentication;
    using CometServer.Authentication.Bearer;
    using CometServer.Configuration;
    using CometServer.Modules;

    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Routing;
    using Microsoft.Extensions.DependencyInjection;

    using Moq;

    using NUnit.Framework;

    /// <summary>
    /// Tests for <see cref="AuthenticationModule"/>.
    /// </summary>
    [TestFixture]
    public class AuthenticationModuleTestFixture
    {
        [Test]
        public async Task LoginReturnsForbiddenWhenLocalJwtSchemeDisabled()
        {
            var (app, appConfigServiceMock, authenticatorMock, jwtServiceMock) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(false);

                var endpoint = GetEndpoint(app, "/login");

                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/login", new { userName = "user", password = "pass" });

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.Forbidden));
                Assert.That(body, Is.EqualTo("Local JWT Authentication is disabled."));

                authenticatorMock.Verify(a => a.Authenticate(It.IsAny<string>(), It.IsAny<string>()), Times.Never);
                jwtServiceMock.Verify(s => s.GenerateTokens(It.IsAny<AuthenticationPerson>()), Times.Never);
            }
        }

        [Test]
        public async Task LoginReturnsTokenWhenAuthenticationSucceeds()
        {
            var (app, appConfigServiceMock, authenticatorMock, jwtServiceMock) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(true);

                var authenticationPerson = new AuthenticationPerson(Guid.NewGuid(), 1);
                authenticatorMock.Setup(a => a.Authenticate("user", "pass")).ReturnsAsync(authenticationPerson);

                var token = new AuthenticationToken("access", "refresh");
                jwtServiceMock.Setup(s => s.GenerateTokens(authenticationPerson)).Returns(token);

                var endpoint = GetEndpoint(app, "/login");

                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/login", new { userName = "user", password = "pass" });

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.OK));
                Assert.That(context.Response.ContentType, Does.StartWith("application/json"));

                using var document = JsonDocument.Parse(body);
                var values = new List<string>();

                foreach (var property in document.RootElement.EnumerateObject())
                {
                    if (property.Value.ValueKind == JsonValueKind.String)
                    {
                        values.Add(property.Value.GetString());
                    }
                }

                Assert.That(values, Does.Contain("access"));
                Assert.That(values, Does.Contain("refresh"));

                authenticatorMock.Verify(a => a.Authenticate("user", "pass"), Times.Once);
                jwtServiceMock.Verify(s => s.GenerateTokens(authenticationPerson), Times.Once);
            }
        }

        [Test]
        public async Task LoginReturnsUnauthorizedWhenAuthenticationFails()
        {
            var (app, appConfigServiceMock, authenticatorMock, _) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(true);
                authenticatorMock.Setup(a => a.Authenticate("user", "pass")).ReturnsAsync((AuthenticationPerson)null);

                var endpoint = GetEndpoint(app, "/login");
                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/login", new { userName = "user", password = "pass" });

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.Unauthorized));
                Assert.That(context.Response.Headers["WWW-Authenticate"].ToString(), Is.EqualTo("Bearer"));
                Assert.That(body, Is.EqualTo("\"not authenticated\""));
            }
        }

        [Test]
        public async Task RefreshReturnsForbiddenWhenSchemeDisabled()
        {
            var (app, appConfigServiceMock, _, jwtServiceMock) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(false);

                var endpoint = GetEndpoint(app, "/refresh");
                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/refresh", "token");

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.Forbidden));
                Assert.That(body, Is.EqualTo("Local JWT Authentication is disabled."));

                jwtServiceMock.Verify(s => s.TryGenerateTokenFromRefreshToken(It.IsAny<string>()), Times.Never);
            }
        }

        [Test]
        public async Task RefreshReturnsTokensWhenRefreshSucceeds()
        {
            var (app, appConfigServiceMock, _, jwtServiceMock) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(true);

                jwtServiceMock.Setup(s => s.TryGenerateTokenFromRefreshToken("token")).ReturnsAsync(new AuthenticationToken("access", "refresh"));

                var endpoint = GetEndpoint(app, "/refresh");
                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/refresh", "token");

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.OK));
                Assert.That(context.Response.ContentType, Does.StartWith("application/json"));
                Assert.That(body, Does.Contain("access"));

                jwtServiceMock.Verify(s => s.TryGenerateTokenFromRefreshToken("token"), Times.Once);
            }
        }

        [Test]
        public async Task RefreshReturnsUnauthorizedWhenRefreshFails()
        {
            var (app, appConfigServiceMock, _, jwtServiceMock) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(JwtBearerDefaults.LocalAuthenticationScheme)).Returns(true);
                jwtServiceMock.Setup(s => s.TryGenerateTokenFromRefreshToken("token")).ThrowsAsync(new InvalidOperationException());

                var endpoint = GetEndpoint(app, "/refresh");
                var context = CreateJsonContext(app.Services, HttpMethods.Post, "/refresh", "token");

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                Assert.That(context.Response.StatusCode, Is.EqualTo((int)HttpStatusCode.Unauthorized));
                Assert.That(context.Response.Headers["WWW-Authenticate"].ToString(), Is.EqualTo("Bearer"));
                Assert.That(body, Is.EqualTo("\"not authenticated\""));
            }
        }

        [Test]
        public async Task ProvideEnabledAuthenticationSchemeReturnsConfiguredValues()
        {
            var (app, appConfigServiceMock, _, _) = this.CreateApp();
            await using (app)
            {
                appConfigServiceMock.Setup(s => s.IsAuthenticationSchemeEnabled(It.IsAny<string>())).Returns<string>(scheme => scheme != JwtBearerDefaults.ExternalAuthenticationScheme);

                var appConfig = new AppConfig();
                appConfig.AuthenticationConfig.ExternalJwtAuthenticationConfig.Authority = "https://authority";
                appConfig.AuthenticationConfig.ExternalJwtAuthenticationConfig.ClientId = "client";
                appConfigServiceMock.SetupGet(s => s.AppConfig).Returns(appConfig);

                var endpoint = GetEndpoint(app, "/auth/schemes");
                var context = CreateJsonContext(app.Services, HttpMethods.Get, "/auth/schemes", null);

                await endpoint.RequestDelegate!(context);

                context.Response.Body.Seek(0, SeekOrigin.Begin);
                using var reader = new StreamReader(context.Response.Body);
                var body = await reader.ReadToEndAsync();

                using var document = JsonDocument.Parse(body);
                var schemes = document.RootElement.GetProperty("Schemes").EnumerateArray().Select(element => element.GetString()).ToArray();

                Assert.That(schemes, Is.EquivalentTo(ApiBase.AuthenticationSchemes.Where(s => s != JwtBearerDefaults.ExternalAuthenticationScheme)));
                Assert.That(document.RootElement.GetProperty("Authority").GetString(), Is.EqualTo(string.Empty));
                Assert.That(document.RootElement.GetProperty("ClientId").GetString(), Is.EqualTo(string.Empty));
            }
        }

        private (WebApplication App, Mock<IAppConfigService> AppConfigService, Mock<IAuthenticationPersonAuthenticator> Authenticator, Mock<IJwtTokenService> JwtTokenService) CreateApp()
        {
            var builder = WebApplication.CreateBuilder();
            builder.Services.AddAuthorization();

            var appConfigService = new Mock<IAppConfigService>();
            appConfigService.SetupGet(s => s.AppConfig).Returns(new AppConfig());

            var authenticator = new Mock<IAuthenticationPersonAuthenticator>();
            var jwtTokenService = new Mock<IJwtTokenService>();

            builder.Services.AddSingleton(appConfigService.Object);
            builder.Services.AddSingleton(authenticator.Object);
            builder.Services.AddSingleton(jwtTokenService.Object);

            var app = builder.Build();
            new AuthenticationModule().AddRoutes(app);

            return (app, appConfigService, authenticator, jwtTokenService);
        }

        private static RouteEndpoint GetEndpoint(WebApplication app, string pattern)
        {
            return app.DataSources.SelectMany(ds => ds.Endpoints).OfType<RouteEndpoint>().Single(e => e.RoutePattern.RawText == pattern);
        }

        private static DefaultHttpContext CreateJsonContext(IServiceProvider services, string method, string path, object payload)
        {
            var context = new DefaultHttpContext
            {
                RequestServices = services
            };

            context.Request.Method = method;
            context.Request.Path = path;

            if (payload != null)
            {
                context.Request.ContentType = "application/json";
                var json = payload is string s ? JsonSerializer.Serialize(s) : JsonSerializer.Serialize(payload);
                var bytes = Encoding.UTF8.GetBytes(json);
                context.Request.Body = new MemoryStream(bytes);
                context.Request.ContentLength = bytes.Length;
            }
            else
            {
                context.Request.Body = new MemoryStream();
                context.Request.ContentLength = 0;
            }

            context.Response.Body = new MemoryStream();

            return context;
        }
    }
}
